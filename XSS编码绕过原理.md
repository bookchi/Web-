# XSS利用编码绕过

[toc]

对于XSS的绕过，很多都是张口就来编码，但是编码那么多，什么时候可以用编码，该用何种编码，怎么用编码？其中又是什么原理？（when，which，how and why

## 请求网页的解码过程

编码是计算机的基础知识，内容加起来能出门，不过或多或少我们都有一些了解。总的来说，编码就是讲字符变为二进制数，而解码就是还原二进制数为字符。从浏览器请求url到在页面上显示网页，也经历了一些解码和编码过程。下面是大概的流程：

- url编码

  是为了允许url中存在汉字这样的非标准字符，本质上就是把一个字符->%加上utf-8编码对应的hex数字，所以又称之为Percent-encoding

  在server段收到请求时，会自动对请求进行一次url解码。

- html编码/解码

  当浏览器收到server端发送来的二进制数据后，首选会对它进行html解码，呈现出来的就是我们看到的源代码。具体的解码方式依情况而定，所以我们要在页面中指定编码，防止浏览器按照错误的方式解码，造成乱码。

  比如百度首页就制定了解码方式为utf-8；

  ![为了找到重点，对其余地方打码](https://saucer-man.com/usr/uploads/sina/5cc5cfe8c7019.jpg)

  但是在HTML中有些字符是和关键词冲突的，比如`<、>、&`，解码之后，浏览器会误认为它们是标签，怎么解决呢？

  为了正确显示预留字符，我们需要在html源码中使用字符实体，比如我们常见的空格` &nbsp;`字符实体以&开头+预先定义的实体名称表示。但不是所有的字符都有实体名称，但是它们都有实体编号，也可以用&#开头+实体编号+分号表示。比如：

  > 实体编号是根据什么编的？

  | 显示结果 | 描述   | 实体名称 | 实体编号 |
  | -------- | ------ | -------- | -------- |
  | `<`      | 小于号 | `&lt;`   | `&#60;`  |
  | `>`      | 大于号 | `&gt;`   | `&#62;`  |

  浏览器对html解码之后，就开始解析html，将标签转化为内容树中的dom节点，此时识别标签的时候，html解析器是无法识别那些被实体编码的内容的，只有建立起dom树，才能对每个节点的内容进行识别。如果出现实体编码，则会进行实体解码，只要是dom节点里属性的值，都可以被html编码和解析。

  > ？？？

  所以在PHP中，使用htmlspecialchars()函数把预定义的字符转换为HTML实体，只有等到DOM树建立起来后，才会解析HTML实体，起到了XSS防护作用。

  > ？？？

  - js解码(只支持unicode)

    当html解析产生DOM节点后，会根据dom节点来做接下来的解析工作，比如在处理`<script> <style>`这样的标签时，解析器会自动切换到JS解析模式，而`src href`后边加入javascript的位url，也会进入js的解析模式。

    比如`<a href="javascript:alert('</u4e00>')">test</a>`，javascript触发了JS解释器，js会先对内容进行解析，里边有一个转义字符`\u4e00`，签到的u表示它是一个unicode字符，根据后边的数字，解析为`一`，于是在完成js的解析之后，变成了:`href="javascript:alert('<一>')"`

    ![img](https://saucer-man.com/usr/uploads/sina/5cc5cfe92172f.jpg)

## XSS编码实践

先来一个普通的XSS代码`<a href="javascript:alert('xss')">test</a>`，浏览器对其解析的大致过程为：

首先html解析器开始工作，并对href中的字符做html解码，接下来URL解析器对href进行解码

- 正常情况下，一个正常的url链接，如`https://www.baidu.com`，url解析器工作完之后，不需其他解码
- 此环境中，url资源类型为javascript，因此最后一步js解析器还会进行解码，最后解析的脚本被执行

解析顺序为3个环节：html解码->url解码->JS解码

我们可以对亲做一下变形，都可以成功弹框。

- 将javascript:alert("xss")转化为html实体，因为解析html之后，建立起<a>DOM节点，然后对其中的html实体进行解析。

  ```html
  <a href="&#x6a;&#x61;&#x76;&#x61;&#x73;&#x63;&#x72;&#x69;&#x70;&#x74;&#x3a;&#x61;&#x6c;&#x65;&#x72;&#x74;&#x28;&#x27;&#x78;&#x73;&#x73;&#x27;&#x29;">test</a>
  ```

- 对alert做JS编码；因为当html打算对<a>DOM节点进行html实体解析时，发现URL资源类型为JavaScript，还因此会调用JS解析器对js代码进行解析。

  ```html
  <a href="javascript:\u0061\u006c\u0065\u0072\u0074('xss')">test</a>
  ```

- 也可利用解码顺序进行混合编码

  ```html
  1. 原代码
  <a href="javascript:alert('xss')">test</a>
  2. 对alert进行JS编码（unicode编码）
  <a href="javascript:\u0061\u006c\u0065\u0072\u0074('xss')">test</a>
  3. 对href标签中的\u0061\u006c\u0065\u0072\u0074进行URL编码
  <a href="javascript:%5c%75%30%30%36%31%5c%75%30%30%36%63%5c%75%30%30%36%35%5c%75%30%30%37%32%5c%75%30%30%37%34('xss')">test</a>
  4. 对href标签中的javascript:%5c%75%30%30%36%31%5c%75%30%30%36%63%5c%75%30%30%36%35%5c%75%30%30%37%32%5c%75%30%30%37%34('xss')进行HTML编码：
  <a href="&#x6a;&#x61;&#x76;&#x61;&#x73;&#x63;&#x72;&#x69;&#x70;&#x74;&#x3a;&#x25;&#x35;&#x63;&#x25;&#x37;&#x35;&#x25;&#x33;&#x30;&#x25;&#x33;&#x30;&#x25;&#x33;&#x36;&#x25;&#x33;&#x31;&#x25;&#x35;&#x63;&#x25;&#x37;&#x35;&#x25;&#x33;&#x30;&#x25;&#x33;&#x30;&#x25;&#x33;&#x36;&#x25;&#x36;&#x33;&#x25;&#x35;&#x63;&#x25;&#x37;&#x35;&#x25;&#x33;&#x30;&#x25;&#x33;&#x30;&#x25;&#x33;&#x36;&#x25;&#x33;&#x35;&#x25;&#x35;&#x63;&#x25;&#x37;&#x35;&#x25;&#x33;&#x30;&#x25;&#x33;&#x30;&#x25;&#x33;&#x37;&#x25;&#x33;&#x32;&#x25;&#x35;&#x63;&#x25;&#x37;&#x35;&#x25;&#x33;&#x30;&#x25;&#x33;&#x30;&#x25;&#x33;&#x37;&#x25;&#x33;&#x34;&#x28;&#x27;&#x78;&#x73;&#x73;&#x27;&#x29;">test</a>
  ```

  怎么样？！经过三种编码都阔以弹框，是不是很开心！

  问题来了，既然浏览器会对`href`里的链接做一次url解码，是不是能对它里面的整体做一次编码呢

  ```html
  <a href="javascript:alert('xss')">test</a>
  对href里的javascript:alert('xss')做一次url编码
  <a href="%6a%61%76%61%73%63%72%69%70%74%3a%61%6c%65%72%74%28%27%78%73%73%27%29">test</a>
  ```

  ![img](https://saucer-man.com/usr/uploads/sina/5cc5cfe9a4084.jpg)

  显然，根据结果这样并不可行。这涉及到一个url解析过程中的一个细节， 不能对协议类型进行任何的编码操作，否则url解析器会认为它无类型，这就导致了上面dom节点中被编码的“JavaScript”没有解码，当然就不会被url解析器识别了。就比如，`http://www.baidu.com`可以被编码为`http://%77%77%77%2e%62%61%69%64%75%2e%63%6f%6d`，但是不能把协议也编码了：`%68%74%74%70%3a%2f%2f%77%77%77%2e%62%61%69%64%75%2e%63%6f%6d`。

  和上面解析情况类似的XSS代码为：

  ```html
  <img src=xxx onerror="javascript:alert(1)">
  ```

  对其稍作变形：

  ```html
  1. 对JavaScript：alert(1)进行html编码
  <img src=xxx onerror="&#x6a;&#x61;&#x76;&#x61;&#x73;&#x63;&#x72;&#x69;&#x70;&#x74;&#x3a;&#x61;&#x6c;&#x65;&#x72;&#x74;&#x28;&#x31;&#x29;">
  2. 对alert进行JS编码
  <img src=xxx onerror="javascript:\u0061\u006c\u0065\u0072\u0074(1)">
  3. 以上两种方法混用
  <img src=xxx onerror="&#x6a;&#x61;&#x76;&#x61;&#x73;&#x63;&#x72;&#x69;&#x70;&#x74;&#x3a;&#x5c;&#x75;&#x30;&#x30;&#x36;&#x31;&#x5c;&#x75;&#x30;&#x30;&#x36;&#x63;&#x5c;&#x75;&#x30;&#x30;&#x36;&#x35;&#x5c;&#x75;&#x30;&#x30;&#x37;&#x32;&#x5c;&#x75;&#x30;&#x30;&#x37;&#x34;&#x28;&#x31;&#x29;">
  ```

  再试试我们的终极大杀器：

  ```html
  <script>alert(1)</script>
  ```

  对其进行编码

  ```html
  1. 对alert进行JS编码
  <script>\u0077\u0069\u006e\u0064\u006f\u0077(1)</script>
  注意：这里是不能对alert(1)进行HTML编码的，因为HTML解析时发现这个DOM节点是script，会调用JS解析来解析其中的内容。但是有个小技巧为：
  <svg><script>&#x61;&#x6c;&#x65;&#x72;&#x74;&#x28;&#x27;&#x78;&#x73;&#x73;&#x27;&#x29;</script>
  ```

  还有个小细节：

  对于刚才JS编码时，我们只编码了`alert('xss')`中的`alert`，这里能不能一起编码了？答案是不能。在进行JS解析的时候，字符or字符串仅会被解码为字符串文本or标识符名称，在上例中，JS解析器正常工作时，将`\u0061\u006c\u0065\u0072\u0074`进行解码后为`alert`，而`alert`是一个有效的标识符名称，它是能被正常解析的。像圆括号、双引号、单引号等等这些字符就只能被当作普通的文本，从而导致无法执行，比如`alert('aaa\u0027)`解析后缺少闭合的单引号而无法执行成功。

  > 这段又在说什么？？？
  >
  > ​	好像懂了

  关于XSS编码的内容就这么多，总之学习任何知识都需要理解原理，回头看看，总能会发现自己不会的点。

## 总结
编码顺序：HTML解码-》实体解码-〉URL解码-》JS解码

## Reference
- copy自博客[探索XSS利用编码绕过的原理](https://saucer-man.com/information_security/103.html)
